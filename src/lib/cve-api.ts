import axios, { AxiosResponse } from 'axios';

// CVE API Configuration
const CVE_API_BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

export const cveApi = axios.create({
  baseURL: CVE_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// CVE API Types
export interface CVEDescription {
  lang: string;
  value: string;
}

export interface CVEMetrics {
  cvssMetricV40?: Array<{
    source: string;
    type: string;
    cvssData: {
      version: string;
      vectorString: string;
      baseScore: number;
      baseSeverity: string;
      attackVector: string;
      attackComplexity: string;
      attackRequirements: string;
      privilegesRequired: string;
      userInteraction: string;
      vulnConfidentialityImpact: string;
      vulnIntegrityImpact: string;
      vulnAvailabilityImpact: string;
      subConfidentialityImpact: string;
      subIntegrityImpact: string;
      subAvailabilityImpact: string;
      exploitMaturity: string;
      confidentialityRequirement: string;
      integrityRequirement: string;
      availabilityRequirement: string;
      modifiedAttackVector: string;
      modifiedAttackComplexity: string;
      modifiedAttackRequirements: string;
      modifiedPrivilegesRequired: string;
      modifiedUserInteraction: string;
      modifiedVulnConfidentialityImpact: string;
      modifiedVulnIntegrityImpact: string;
      modifiedVulnAvailabilityImpact: string;
      modifiedSubConfidentialityImpact: string;
      modifiedSubIntegrityImpact: string;
      modifiedSubAvailabilityImpact: string;
      Safety: string;
      Automatable: string;
      Recovery: string;
      valueDensity: string;
      vulnerabilityResponseEffort: string;
      providerUrgency: string;
    };
  }>;
  cvssMetricV31?: Array<{
    source: string;
    type: string;
    cvssData: {
      version: string;
      vectorString: string;
      baseScore: number;
      baseSeverity: string;
      attackVector: string;
      attackComplexity: string;
      privilegesRequired: string;
      userInteraction: string;
      scope: string;
      confidentialityImpact: string;
      integrityImpact: string;
      availabilityImpact: string;
    };
    exploitabilityScore: number;
    impactScore: number;
  }>;
  cvssMetricV30?: Array<{
    source: string;
    type: string;
    cvssData: {
      version: string;
      vectorString: string;
      baseScore: number;
      baseSeverity: string;
      attackVector: string;
      attackComplexity: string;
      privilegesRequired: string;
      userInteraction: string;
      scope: string;
      confidentialityImpact: string;
      integrityImpact: string;
      availabilityImpact: string;
    };
    exploitabilityScore: number;
    impactScore: number;
  }>;
  cvssMetricV2?: Array<{
    source: string;
    type: string;
    cvssData: {
      version: string;
      vectorString: string;
      baseScore: number;
      baseSeverity: string;
      accessVector: string;
      accessComplexity: string;
      authentication: string;
      confidentialityImpact: string;
      integrityImpact: string;
      availabilityImpact: string;
    };
    exploitabilityScore: number;
    impactScore: number;
  }>;
}

export interface CVEWeakness {
  source: string;
  type: string;
  description: CVEDescription[];
}

export interface CVEConfiguration {
  cveId: string;
  operator: string;
  negate: boolean;
  nodes: {
    operator: string;
    negate: boolean;
    cpeMatch: {
      vulnerable: boolean;
      criteria: string;
      matchCriteriaId: string;
      versionStartIncluding?: string;
      versionStartExcluding?: string;
      versionEndIncluding?: string;
      versionEndExcluding?: string;
    }[];
  }[];
}

export interface CVEReference {
  url: string;
  source: string;
  tags?: string[];
}

export interface CVECVE {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    cveTags?: string[];
    evaluatorComment?: string;
    evaluatorImpact?: string;
    evaluatorSolution?: string;
    cisaExploitAdd?: string;
    cisaActionDue?: string;
    cisaRequiredAction?: string;
    cisaVulnerabilityName?: string;
    descriptions: CVEDescription[];
    metrics: CVEMetrics;
    weaknesses?: CVEWeakness[];
    configurations?: CVEConfiguration[];
    references?: CVEReference[];
  };
}

export interface CVESearchParams {
  cpeName?: string;
  cveId?: string;
  cveTag?: 'disputed' | 'unsupported-when-assigned' | 'exclusively-hosted-service';
  cvssV2Metrics?: string;
  cvssV2Severity?: 'LOW' | 'MEDIUM' | 'HIGH';
  cvssV3Metrics?: string;
  cvssV3Severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssV4Metrics?: string;
  cvssV4Severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cweId?: string;
  hasCertAlerts?: boolean;
  hasCertNotes?: boolean;
  hasKev?: boolean;
  hasOval?: boolean;
  isVulnerable?: boolean;
  kevStartDate?: string;
  kevEndDate?: string;
  keywordSearch?: string;
  keywordExactMatch?: boolean;
  lastModStartDate?: string;
  lastModEndDate?: string;
  noRejected?: boolean;
  pubStartDate?: string;
  pubEndDate?: string;
  resultsPerPage?: number;
  startIndex?: number;
  sourceIdentifier?: string;
  versionEnd?: string;
  versionEndType?: 'including' | 'excluding';
  versionStart?: string;
  versionStartType?: 'including' | 'excluding';
  virtualMatchString?: string;
}

export interface CVESearchResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  timestamp: string;
  vulnerabilities: CVECVE[];
}

export interface CVESearchFilters {
  // Basic filters
  cveId?: string;
  keywordSearch?: string;
  keywordExactMatch?: boolean;
  
  // CPE filters
  cpeName?: string;
  virtualMatchString?: string;
  isVulnerable?: boolean;
  versionStart?: string;
  versionStartType?: 'including' | 'excluding';
  versionEnd?: string;
  versionEndType?: 'including' | 'excluding';
  
  // CVSS filters
  cvssV2Severity?: 'LOW' | 'MEDIUM' | 'HIGH';
  cvssV2Metrics?: string;
  cvssV3Severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssV3Metrics?: string;
  cvssV4Severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cvssV4Metrics?: string;
  
  // CWE filters
  cweId?: string;
  
  // Date filters
  pubStartDate?: string;
  pubEndDate?: string;
  lastModStartDate?: string;
  lastModEndDate?: string;
  kevStartDate?: string;
  kevEndDate?: string;
  
  // Status filters
  cveTag?: 'disputed' | 'unsupported-when-assigned' | 'exclusively-hosted-service';
  hasCertAlerts?: boolean;
  hasCertNotes?: boolean;
  hasKev?: boolean;
  hasOval?: boolean;
  noRejected?: boolean;
  
  // Source filters
  sourceIdentifier?: string;
  
  // Pagination
  resultsPerPage?: number;
  startIndex?: number;
}

// CVE API Functions
export const cveApiService = {
  // Search CVEs with filters
  searchCVEs: (filters: CVESearchFilters = {}): Promise<AxiosResponse<CVESearchResponse>> => {
    const params = new URLSearchParams();
    
    // Helper function to check if a value is empty
    const isEmpty = (value: any): boolean => {
      if (value === undefined || value === null) return true;
      if (typeof value === 'string') return value.trim() === '';
      if (Array.isArray(value)) return value.length === 0;
      if (typeof value === 'object') return Object.keys(value).length === 0;
      return false;
    };
    
    // Add all non-empty parameters from filters
    Object.entries(filters).forEach(([key, value]) => {
      if (!isEmpty(value)) {
        if (typeof value === 'boolean') {
          if (value) {
            params.append(key, '');
          }
        } else {
          params.append(key, value.toString());
        }
      }
    });
    
    // Add default pagination parameters only if not provided in filters
    if (!params.has('resultsPerPage')) {
      params.append('resultsPerPage', '20');
    }
    if (!params.has('startIndex')) {
      params.append('startIndex', '0');
    }
    
    return cveApi.get(`?${params.toString()}`);
  },

  // Get specific CVE by ID
  getCVEById: (cveId: string): Promise<AxiosResponse<CVESearchResponse>> => {
    if (!cveId || cveId.trim() === '') {
      throw new Error('CVE ID is required');
    }
    const params = new URLSearchParams();
    params.append('cveId', cveId.trim());
    params.append('resultsPerPage', '20');
    params.append('startIndex', '0');
    return cveApi.get(`?${params.toString()}`);
  },

  // Get CVEs by CPE name
  getCVEsByCPE: (cpeName: string, isVulnerable?: boolean): Promise<AxiosResponse<CVESearchResponse>> => {
    if (!cpeName || cpeName.trim() === '') {
      throw new Error('CPE name is required');
    }
    const params = new URLSearchParams();
    params.append('cpeName', cpeName.trim());
    params.append('resultsPerPage', '20');
    params.append('startIndex', '0');
    if (isVulnerable) {
      params.append('isVulnerable', '');
    }
    return cveApi.get(`?${params.toString()}`);
  },

  // Get CVEs by keyword search
  searchCVEsByKeyword: (keyword: string, exactMatch?: boolean): Promise<AxiosResponse<CVESearchResponse>> => {
    if (!keyword || keyword.trim() === '') {
      throw new Error('Keyword is required');
    }
    const params = new URLSearchParams();
    params.append('keywordSearch', keyword.trim());
    params.append('resultsPerPage', '20');
    params.append('startIndex', '0');
    if (exactMatch) {
      params.append('keywordExactMatch', '');
    }
    return cveApi.get(`?${params.toString()}`);
  },

  // Get CVEs by CVSS severity
  getCVEsBySeverity: (severity: string, version: 'v2' | 'v3' | 'v4' = 'v3'): Promise<AxiosResponse<CVESearchResponse>> => {
    const params = new URLSearchParams();
    const severityParam = version === 'v2' ? 'cvssV2Severity' : 
                         version === 'v3' ? 'cvssV3Severity' : 'cvssV4Severity';
    params.append(severityParam, severity);
    params.append('resultsPerPage', '20');
    params.append('startIndex', '0');
    return cveApi.get(`?${params.toString()}`);
  },

  // Get CVEs by date range
  getCVEsByDateRange: (startDate: string, endDate: string, type: 'published' | 'modified' | 'kev' = 'published'): Promise<AxiosResponse<CVESearchResponse>> => {
    const params = new URLSearchParams();
    const startParam = type === 'published' ? 'pubStartDate' : 
                      type === 'modified' ? 'lastModStartDate' : 'kevStartDate';
    const endParam = type === 'published' ? 'pubEndDate' : 
                    type === 'modified' ? 'lastModEndDate' : 'kevEndDate';
    params.append(startParam, startDate);
    params.append(endParam, endDate);
    params.append('resultsPerPage', '20');
    params.append('startIndex', '0');
    return cveApi.get(`?${params.toString()}`);
  },

  // Get recent CVEs (last 30 days)
  getRecentCVEs: (days: number = 30): Promise<AxiosResponse<CVESearchResponse>> => {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    // Ensure we don't have future dates
    const now = new Date();
    if (endDate > now) {
      endDate.setTime(now.getTime());
    }
    if (startDate > now) {
      startDate.setTime(now.getTime() - (days * 24 * 60 * 60 * 1000));
    }
    
    // Format dates properly for NVD API
    const formatDate = (date: Date) => {
      return date.toISOString().split('T')[0] + 'T00:00:00.000';
    };
    
    return cveApiService.getCVEsByDateRange(
      formatDate(startDate),
      formatDate(endDate),
      'published'
    );
  },

  // Get CVEs with pagination
  getCVEsWithPagination: (page: number = 0, limit: number = 20): Promise<AxiosResponse<CVESearchResponse>> => {
    const params = new URLSearchParams();
    params.append('startIndex', (page * limit).toString());
    params.append('resultsPerPage', limit.toString());
    return cveApi.get(`?${params.toString()}`);
  }
};

// Helper functions
export const formatCVEDate = (dateString: string): string => {
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

export const getCVSSSeverityColor = (severity: string): string => {
  switch (severity?.toUpperCase()) {
    case 'CRITICAL':
      return 'text-red-600 bg-red-50 border-red-200';
    case 'HIGH':
      return 'text-orange-600 bg-orange-50 border-orange-200';
    case 'MEDIUM':
      return 'text-yellow-600 bg-yellow-50 border-yellow-200';
    case 'LOW':
      return 'text-green-600 bg-green-50 border-green-200';
    default:
      return 'text-gray-600 bg-gray-50 border-gray-200';
  }
};

export const getCVSSScoreColor = (score: number): string => {
  if (score >= 9.0) return 'text-red-600 bg-red-50 border-red-200';
  if (score >= 7.0) return 'text-orange-600 bg-orange-50 border-orange-200';
  if (score >= 4.0) return 'text-yellow-600 bg-yellow-50 border-yellow-200';
  return 'text-green-600 bg-green-50 border-green-200';
};

export const truncateText = (text: string, maxLength: number = 100): string => {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
};

export const getCVSSData = (cve: CVECVE) => {
  const metrics = cve.cve.metrics;
  if (metrics?.cvssMetricV40 && metrics.cvssMetricV40.length > 0) {
    const cvssData = metrics.cvssMetricV40[0].cvssData;
    return {
      version: 'v4',
      score: cvssData.baseScore,
      severity: cvssData.baseSeverity,
      vector: cvssData.vectorString,
      data: cvssData,
    };
  } else if (metrics?.cvssMetricV31 && metrics.cvssMetricV31.length > 0) {
    const cvssData = metrics.cvssMetricV31[0].cvssData;
    return {
      version: 'v3.1',
      score: cvssData.baseScore,
      severity: cvssData.baseSeverity,
      vector: cvssData.vectorString,
      data: cvssData,
    };
  } else if (metrics?.cvssMetricV30 && metrics.cvssMetricV30.length > 0) {
    const cvssData = metrics.cvssMetricV30[0].cvssData;
    return {
      version: 'v3.0',
      score: cvssData.baseScore,
      severity: cvssData.baseSeverity,
      vector: cvssData.vectorString,
      data: cvssData,
    };
  } else if (metrics?.cvssMetricV2 && metrics.cvssMetricV2.length > 0) {
    const cvssData = metrics.cvssMetricV2[0].cvssData;
    return {
      version: 'v2',
      score: cvssData.baseScore,
      severity: cvssData.baseSeverity,
      vector: cvssData.vectorString,
      data: cvssData,
    };
  }
  return null;
};

export const getDescription = (cve: CVECVE) => {
  const englishDesc = cve.cve.descriptions?.find(desc => desc.lang === 'en');
  return englishDesc?.value || cve.cve.descriptions?.[0]?.value || 'No description available';
};

export const getCPEProducts = (cve: CVECVE) => {
  if (!cve.cve.configurations) return [];
  
  const products = new Set<string>();
  cve.cve.configurations.forEach(config => {
    config.nodes?.forEach(node => {
      node.cpeMatch?.forEach(match => {
        const cpeInfo = extractCPEInfo(match.criteria);
        if (cpeInfo) {
          products.add(`${cpeInfo.vendor} ${cpeInfo.product}`);
        }
      });
    });
  });
  
  return Array.from(products).slice(0, 5); // Show max 5 products
};

export const getCPEDetails = (cve: CVECVE) => {
  if (!cve.cve.configurations) return [];
  
  const products = new Map<string, any>();
  cve.cve.configurations.forEach(config => {
    config.nodes?.forEach(node => {
      node.cpeMatch?.forEach(match => {
        const cpeInfo = extractCPEInfo(match.criteria);
        if (cpeInfo) {
          const key = `${cpeInfo.vendor}:${cpeInfo.product}`;
          if (!products.has(key)) {
            products.set(key, {
              vendor: cpeInfo.vendor,
              product: cpeInfo.product,
              version: cpeInfo.version,
              vulnerable: match.vulnerable,
              criteria: match.criteria,
            });
          }
        }
      });
    });
  });
  
  return Array.from(products.values());
};

export const extractCPEInfo = (cpeString: string) => {
  const parts = cpeString.split(':');
  if (parts.length < 5) return null;
  
  return {
    part: parts[2],
    vendor: parts[3],
    product: parts[4],
    version: parts[5] || '*',
    update: parts[6] || '*',
    edition: parts[7] || '*',
    language: parts[8] || '*',
    sw_edition: parts[9] || '*',
    target_sw: parts[10] || '*',
    target_hw: parts[11] || '*',
    other: parts[12] || '*'
  };
};
